#[doc = " `Any` contains an arbitrary serialized protocol buffer message along with a"]
#[doc = " URL that describes the type of the serialized message."]
#[doc = ""]
#[doc = " Protobuf library provides support to pack/unpack Any values in the form"]
#[doc = " of utility functions or additional generated methods of the Any type."]
#[doc = ""]
#[doc = " Example 1: Pack and unpack a message in C++."]
#[doc = ""]
#[doc = "      Foo foo = ...;"]
#[doc = "      Any any;"]
#[doc = "      any.PackFrom(foo);"]
#[doc = "      ..."]
#[doc = "      if (any.UnpackTo(&foo)) {"]
#[doc = "        ..."]
#[doc = "      }"]
#[doc = ""]
#[doc = " Example 2: Pack and unpack a message in Java."]
#[doc = ""]
#[doc = "      Foo foo = ...;"]
#[doc = "      Any any = Any.pack(foo);"]
#[doc = "      ..."]
#[doc = "      if (any.is(Foo.class)) {"]
#[doc = "        foo = any.unpack(Foo.class);"]
#[doc = "      }"]
#[doc = ""]
#[doc = "   Example 3: Pack and unpack a message in Python."]
#[doc = ""]
#[doc = "      foo = Foo(...)"]
#[doc = "      any = Any()"]
#[doc = "      any.Pack(foo)"]
#[doc = "      ..."]
#[doc = "      if any.Is(Foo.DESCRIPTOR):"]
#[doc = "        any.Unpack(foo)"]
#[doc = "        ..."]
#[doc = ""]
#[doc = "   Example 4: Pack and unpack a message in Go"]
#[doc = ""]
#[doc = "       foo := &pb.Foo{...}"]
#[doc = "       any, err := ptypes.MarshalAny(foo)"]
#[doc = "       ..."]
#[doc = "       foo := &pb.Foo{}"]
#[doc = "       if err := ptypes.UnmarshalAny(any, foo); err != nil {"]
#[doc = "         ..."]
#[doc = "       }"]
#[doc = ""]
#[doc = " The pack methods provided by protobuf library will by default use"]
#[doc = " 'type.googleapis.com/full.type.name' as the type URL and the unpack"]
#[doc = " methods only use the fully qualified type name after the last '/'"]
#[doc = " in the type URL, for example \"foo.bar.com/x/y.z\" will yield type"]
#[doc = " name \"y.z\"."]
#[doc = ""]
#[doc = ""]
#[doc = " JSON"]
#[doc = " ===="]
#[doc = " The JSON representation of an `Any` value uses the regular"]
#[doc = " representation of the deserialized, embedded message, with an"]
#[doc = " additional field `@type` which contains the type URL. Example:"]
#[doc = ""]
#[doc = "      package google.profile;"]
#[doc = "      message Person {"]
#[doc = "        string first_name = 1;"]
#[doc = "        string last_name = 2;"]
#[doc = "      }"]
#[doc = ""]
#[doc = "      {"]
#[doc = "        \"@type\": \"type.googleapis.com/google.profile.Person\","]
#[doc = "        \"firstName\": <string>,"]
#[doc = "        \"lastName\": <string>"]
#[doc = "      }"]
#[doc = ""]
#[doc = " If the embedded message type is well-known and has a custom JSON"]
#[doc = " representation, that representation will be embedded adding a field"]
#[doc = " `value` which holds the custom JSON in addition to the `@type`"]
#[doc = " field. Example (for message [google.protobuf.Duration][]):"]
#[doc = ""]
#[doc = "      {"]
#[doc = "        \"@type\": \"type.googleapis.com/google.protobuf.Duration\","]
#[doc = "        \"value\": \"1.212s\""]
#[doc = "      }"]
#[doc = ""]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, :: prost :: Message)]
pub struct Any {
    #[doc = " A URL/resource name that uniquely identifies the type of the serialized"]
    #[doc = " protocol buffer message. This string must contain at least"]
    #[doc = " one \"/\" character. The last segment of the URL's path must represent"]
    #[doc = " the fully qualified name of the type (as in"]
    #[doc = " `path/google.protobuf.Duration`). The name should be in a canonical form"]
    #[doc = " (e.g., leading \".\" is not accepted)."]
    #[doc = ""]
    #[doc = " In practice, teams usually precompile into the binary all types that they"]
    #[doc = " expect it to use in the context of Any. However, for URLs which use the"]
    #[doc = " scheme `http`, `https`, or no scheme, one can optionally set up a type"]
    #[doc = " server that maps type URLs to message definitions as follows:"]
    #[doc = ""]
    #[doc = " * If no scheme is provided, `https` is assumed."]
    #[doc = " * An HTTP GET on the URL must yield a [google.protobuf.Type][]"]
    #[doc = "    value in binary format, or produce an error."]
    #[doc = " * Applications are allowed to cache lookup results based on the"]
    #[doc = "    URL, or have them precompiled into a binary to avoid any"]
    #[doc = "    lookup. Therefore, binary compatibility needs to be preserved"]
    #[doc = "    on changes to types. (Use versioned type names to manage"]
    #[doc = "    breaking changes.)"]
    #[doc = ""]
    #[doc = " Note: this functionality is not currently available in the official"]
    #[doc = " protobuf release, and it is not used for type URLs beginning with"]
    #[doc = " type.googleapis.com."]
    #[doc = ""]
    #[doc = " Schemes other than `http`, `https` (or the empty scheme) might be"]
    #[doc = " used with implementation specific semantics."]
    #[doc = ""]
    #[prost(string, tag = "1")]
    #[cfg_attr(feature = "serde", serde(rename = "@type"))]
    pub type_url: ::prost::alloc::string::String,
    #[doc = " Must be a valid serialized protocol buffer of the above specified type."]
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
